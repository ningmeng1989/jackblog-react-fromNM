<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>ReactJS 教程</title>
 </head>
 <body>

(SIX)、Interactivity and Dynamic UIs

You've alraedy learned how to display data with React.Now let's look at

(SEVEN)、Multiple Components

动机：创建有良好定义的接口利用别的组件的模块组件，你可以获得像用函数和类一样的好处。只需要简单的创建新的组件，你就可以明显的把你的app的关注点分散开来。为你的app创建一套定制的组件库，你可以用最适合你的领域的方式表达你的UI。

var Avatar =React.createClass({
	render:
})

所有权关系：

this.props.children 是一个不透明的数据结构，使用React.Children工具操作他们。

调谐是React用新的render传递更新DOM的过程，通常，子类根据渲染时的顺序更新

??Child Reconciliation
??Stateful Children

Dynamic Component

key应在容器中赋值，而不是在组件内部赋值

数据流：从所有者到被拥有者
单向数据绑定，有效率，递归，数据绑定反应在所有被用到的地方

性能提示：

你可能觉得如果一个组件拥有很多子组件，改变数据会很消耗，但是，JS很快，而且render函数一般很简单，在大多数应用中这是很快的。而且，瓶颈常常是DOM更新，而不是JS执行。React会凭借批量更新和更新检测来为你优化这点。
然而，有时，你真的想对你的性能有更好的控制。这种情况，简单的重写shouldComponentUpdate()并返回false，当你希望React跳过一个支树的进行。
当shouldComponent返回false，React将不能保存你的UI同步。在这样做的时候，请确定你知道你在做神马，只在你有突出的性能问题是使用这个函数。不要低估JS相对于DOM的速度。

(EIGHT)、Reusable Component

当设计接口时，拆解常用的设计元素成有良好定义接口的可重用的组件。这样，下次你需要创建一些UI，你可以少写很多代码。这意味着更快的开发时间，更少的BUG，和更好的字节。

Prop Validation
（属性验证）

React.PropTypes暴露了很多验证方法可以用来保证你收到的数据是有效的，当一个无效的数据被提供给一个prop，控制台会打出一个警告，出于性能的考虑，propTypes只在开发模式时被检查。

单个子组件

默认属性值：
getDefaultProps()的结果会被缓存并被用来保证属性有一个值，如果没在父组件中被指定
。这允许你可以安全的使用你的属性，而不需要你自己用重复的零碎的代码来控制。

传递属性：捷径

混合：
解决有时很不同的组件的共享相同的方法

ES6 类

class XXX extends React.Component{
	
}

这样定义组件与React.createClass的不同点是：
没有getInitialState方法，但是可以在构造方法constructor中设置
propTypes和defaultProps作为属性在constructor中被定义，而不是在class内

NoAutobinding 没有自动绑定

跟随ES6来的语义方法，意味着它们不会自动给实例绑定this，你必须明确地使用.bind(this)或者箭头函数。

我们推荐你在constructor中绑定事件处理句柄，这样它们只为每个实例绑定一次。
这样性能更好，尤其是如果你实现了shouldComponentUpdate方法，

ES6不能支持mixin

无状态方法
普通JS写法
这样的写法不能保持internal state，没有后退实例，没有生命周期方法。它们是简单的方法传递。
然后它们可以指定属性类型和默认属性值

(Nine)、传递属性值

属性合并
more Object.assign()

手动传递

在JSX中用...传递
解构语法
这样保证了你传递了所有属性，除了你自己消费的

消费和传递同样的属性

剩余传播属性

如果不用JSX，可以用JS库来实现一样的功能，比如Underscore
_.omit过滤属性
_.extend复制属性到新的对象

(TEN)、Forms

表单组件可以通过用户交互改变值
交互属性：
value
checked
selected

受控组件：
getInitialState
handleChange
render

不受控组件：
defaultValue

defaultChecked
defaultValue

进阶
node.getAttribute('value')

Textarea Value
--当用value的时候，不应该用子节点

必要的操作：
如果你必须要执行一个操作，你必须保持一个对节点的指向，因此，如果，你必须提交一个表单，有一种方法就是，获得一个from元素的指向，然后手动触发表单提交方法。

(ELEVEN)、Working With the Browser

React提供了一个强大的抽象，让你在大多数情况下可以不用直接操作DOM元素，但是，有时，你需要用到已有的API，可能是用一个第三方库，或者已存在的代码。

【1】、The Virtual DOM

React非常快，因为它不直接操作DOM，React维护了一个快速的DOM缓存代表。render方法实际上会返回一个DOM陈述，然后，React可以和缓存中的陈述比较来计算出最快的方法来更新浏览器上的DOM。

并且，React实现了一整套合成事件系统，这样所有事件对象可以保证遵守W3C的规则，而不管浏览器的差异，所有东西在各浏览器中，冒泡一致并且高效。你甚至可以使用HTML5的事件在老的平常不支持这些事件的浏览器中。

大部分时候，你应该呆在React的假的浏览器的世界里，因为这性能更好，更简单。然而，有时，你要和已有的API打交道，可能是用一个第三方库，例如jQuery。React为你提供了逃生舱来直接使用这些已有的DOM API。

【2】、Refs and findDOMNode()

要和浏览器交互，你需要一个DOM节点的引用，你可以给任何元素添加ref，这让你可以引用组件的支持实例。如果你想调用这个组件上的必要的方法，或者想和已有的DOM节点打交道，这会很有用。要深入了解refs，包括如何高效地使用它们的方法，可以看refs to components这篇文章。

【3】、组件声明周期：

组件的生命周期可以分为三个主要部分：

React提供了生命周期方法让你可以在过程中指定钩子函数。我们提供will方法-当某个事件正要发生时触发，以及did方法-当某个事件刚刚发生了的时候触发。

1.Mounting-一个组件被插入DOM

	getInitialState--当组件被插入DOM之前触发，有状态的组件可以实现这个方法，并且返回初始值；

	componentWillMount--当插入正要发生时触发；

	componentDidMount--当插入刚刚完成使触发，那些需要DOM节点的初始化方法应该放在这里。

2.Updating-一个组件被重新渲染来决定DOM是否要更新

	componentWillReceiveProps（object nexrProps）--当一个已插入到DOM中的组件获得新的属性时触发。这个方法应该用来比较this.props和nextProps，然后用this.setState()方法来完成状态改变；

	shouldComponentUpdate(object nextProps,object nextState)--布尔值被调用，当一个组件决定是否任何改变要保证DOM的更新。使用这个方法是一个优化，当来比较this.props和nextProps this.state和nextState，并且返回false，如果React要跳过更新。

	componentWillUpdate(object nextProps,object nextState)--当DOM更新正要发生时被调用，在这里你不能使用setState方法；

	componentDidUpdate(object prevProp,object prevState)--当DOM更新刚刚完成时时被调用。


3.Unmounting-一个组件被从DOM中移除

	componentWillUnmount()--当一个组件被移除并且被销毁时调用，清除方法应该放在这里。

【4】、Mounted Methods

插入复合组件还支持这个方法

component.forceUpdate()--对任何已被装载的组件，当这个组件有某些更深层的方面已经改变，而不是用this.setState方法改变的。

【5】、浏览器支持

React支持ie9以上，大部分常用浏览器，不支持那些不支持ES5方法的老浏览器，但是你可以在页面中用es5-shim 和es5-sham 来填充。

(TWELVE)、Refs to Components

当你创建你的组件时，你可能会发现自己想要跳出来，调用render函数返回的组件实例上的方法。















































  
 </body>
</html>
